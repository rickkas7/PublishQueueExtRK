<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueExtRK: PublishQueueExt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PublishQueueExtRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">PublishQueueExt Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for asynchronous publishing of events.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_publish_queue_ext_r_k_8h_source.html">PublishQueueExtRK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_publish_queue_ext_1_1_queue_file_trailer.html">QueueFileTrailer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is at the end of the publish queue file.  <a href="struct_publish_queue_ext_1_1_queue_file_trailer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a45c6e19557266a4a33ab51ad5d2a80d0" id="r_a45c6e19557266a4a33ab51ad5d2a80d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c6e19557266a4a33ab51ad5d2a80d0">withFileQueueSize</a> (size_t size)</td></tr>
<tr class="memdesc:a45c6e19557266a4a33ab51ad5d2a80d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the file-based queue size (default is 100)  <br /></td></tr>
<tr class="separator:a45c6e19557266a4a33ab51ad5d2a80d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb48a78373bf334d74df86e286c23f0d" id="r_afb48a78373bf334d74df86e286c23f0d"><td class="memItemLeft" align="right" valign="top"><a id="afb48a78373bf334d74df86e286c23f0d" name="afb48a78373bf334d74df86e286c23f0d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getFileQueueSize</b> () const</td></tr>
<tr class="memdesc:afb48a78373bf334d74df86e286c23f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file queue size. <br /></td></tr>
<tr class="separator:afb48a78373bf334d74df86e286c23f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd49955e24427561875e23305a6aa9c" id="r_a5fd49955e24427561875e23305a6aa9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd49955e24427561875e23305a6aa9c">withDirPath</a> (const char *dirPath)</td></tr>
<tr class="memdesc:a5fd49955e24427561875e23305a6aa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the directory to use as the queue directory. This is required!  <br /></td></tr>
<tr class="separator:a5fd49955e24427561875e23305a6aa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af469e16e7fdd0d552b944d2418aedead" id="r_af469e16e7fdd0d552b944d2418aedead"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af469e16e7fdd0d552b944d2418aedead">getDirPath</a> () const</td></tr>
<tr class="memdesc:af469e16e7fdd0d552b944d2418aedead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the directory path set using <a class="el" href="#a5fd49955e24427561875e23305a6aa9c" title="Sets the directory to use as the queue directory. This is required!">withDirPath()</a>  <br /></td></tr>
<tr class="separator:af469e16e7fdd0d552b944d2418aedead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076c74a202967ed8d7560508373e7873" id="r_a076c74a202967ed8d7560508373e7873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a076c74a202967ed8d7560508373e7873">withPublishCompleteUserCallback</a> (std::function&lt; void(const CloudEvent &amp;event)&gt; cb)</td></tr>
<tr class="memdesc:a076c74a202967ed8d7560508373e7873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback function to call with publish is complete.  <br /></td></tr>
<tr class="separator:a076c74a202967ed8d7560508373e7873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff151cce8ada685b1e2d34e24d83906b" id="r_aff151cce8ada685b1e2d34e24d83906b"><td class="memItemLeft" align="right" valign="top"><a id="aff151cce8ada685b1e2d34e24d83906b" name="aff151cce8ada685b1e2d34e24d83906b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> ()</td></tr>
<tr class="memdesc:aff151cce8ada685b1e2d34e24d83906b"><td class="mdescLeft">&#160;</td><td class="mdescRight">You must call this from <a class="el" href="#aff151cce8ada685b1e2d34e24d83906b" title="You must call this from setup() to initialize this library.">setup()</a> to initialize this library. <br /></td></tr>
<tr class="separator:aff151cce8ada685b1e2d34e24d83906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d667b2ddc76f506ba6db84003dbc7a" id="r_ac9d667b2ddc76f506ba6db84003dbc7a"><td class="memItemLeft" align="right" valign="top"><a id="ac9d667b2ddc76f506ba6db84003dbc7a" name="ac9d667b2ddc76f506ba6db84003dbc7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loop</b> ()</td></tr>
<tr class="memdesc:ac9d667b2ddc76f506ba6db84003dbc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">You must call the loop method from the global <a class="el" href="#ac9d667b2ddc76f506ba6db84003dbc7a" title="You must call the loop method from the global loop() function!">loop()</a> function! <br /></td></tr>
<tr class="separator:ac9d667b2ddc76f506ba6db84003dbc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b51718306124c20d8ad186f5538eb" id="r_aff3b51718306124c20d8ad186f5538eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff3b51718306124c20d8ad186f5538eb">publish</a> (CloudEvent event)</td></tr>
<tr class="memdesc:aff3b51718306124c20d8ad186f5538eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish an event.  <br /></td></tr>
<tr class="separator:aff3b51718306124c20d8ad186f5538eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3612467432edb9b35532f316cc604dde" id="r_a3612467432edb9b35532f316cc604dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3612467432edb9b35532f316cc604dde">publish</a> (const char *eventName)</td></tr>
<tr class="memdesc:a3612467432edb9b35532f316cc604dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:a3612467432edb9b35532f316cc604dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40539be5431fb4797dba65eddfbc73e2" id="r_a40539be5431fb4797dba65eddfbc73e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40539be5431fb4797dba65eddfbc73e2">publish</a> (const char *eventName, const char *data)</td></tr>
<tr class="memdesc:a40539be5431fb4797dba65eddfbc73e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:a40539be5431fb4797dba65eddfbc73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9030cdc4d59259aa514056534f546d43" id="r_a9030cdc4d59259aa514056534f546d43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9030cdc4d59259aa514056534f546d43">publish</a> (const char *eventName, const Variant &amp;data)</td></tr>
<tr class="memdesc:a9030cdc4d59259aa514056534f546d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event from a Variant.  <br /></td></tr>
<tr class="separator:a9030cdc4d59259aa514056534f546d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade52d7bc6df525c3fbf576740d6b92e2" id="r_ade52d7bc6df525c3fbf576740d6b92e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade52d7bc6df525c3fbf576740d6b92e2">publish</a> (const char *eventName, const Variant &amp;data, ContentType type)</td></tr>
<tr class="memdesc:ade52d7bc6df525c3fbf576740d6b92e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event with a Variant and ContentType.  <br /></td></tr>
<tr class="separator:ade52d7bc6df525c3fbf576740d6b92e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a85caba851883ad131fe577ddd6acc" id="r_ac2a85caba851883ad131fe577ddd6acc"><td class="memItemLeft" align="right" valign="top"><a id="ac2a85caba851883ad131fe577ddd6acc" name="ac2a85caba851883ad131fe577ddd6acc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQueues</b> ()</td></tr>
<tr class="memdesc:ac2a85caba851883ad131fe577ddd6acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the file based queue. Any queued events are discarded and the files deleted. <br /></td></tr>
<tr class="separator:ac2a85caba851883ad131fe577ddd6acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5477889eea9b5555a70e9ad19dc000" id="r_abc5477889eea9b5555a70e9ad19dc000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc5477889eea9b5555a70e9ad19dc000">setPausePublishing</a> (bool value)</td></tr>
<tr class="memdesc:abc5477889eea9b5555a70e9ad19dc000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume publishing events.  <br /></td></tr>
<tr class="separator:abc5477889eea9b5555a70e9ad19dc000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd00397946c222241a507dde4fadda6" id="r_a3cd00397946c222241a507dde4fadda6"><td class="memItemLeft" align="right" valign="top"><a id="a3cd00397946c222241a507dde4fadda6" name="a3cd00397946c222241a507dde4fadda6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPausePublishing</b> () const</td></tr>
<tr class="memdesc:a3cd00397946c222241a507dde4fadda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the pause publishing flag. <br /></td></tr>
<tr class="separator:a3cd00397946c222241a507dde4fadda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d836715f52f69367b2fbc32ac7f626" id="r_a41d836715f52f69367b2fbc32ac7f626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d836715f52f69367b2fbc32ac7f626">getCanSleep</a> () const</td></tr>
<tr class="memdesc:a41d836715f52f69367b2fbc32ac7f626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if it's a good time to go to sleep.  <br /></td></tr>
<tr class="separator:a41d836715f52f69367b2fbc32ac7f626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e82c9642ecfa120db037c0ecb559d8" id="r_a45e82c9642ecfa120db037c0ecb559d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e82c9642ecfa120db037c0ecb559d8">getNumEvents</a> ()</td></tr>
<tr class="memdesc:a45e82c9642ecfa120db037c0ecb559d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of events queued.  <br /></td></tr>
<tr class="separator:a45e82c9642ecfa120db037c0ecb559d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0261edf1d643dd42d8791c74d9b06433" id="r_a0261edf1d643dd42d8791c74d9b06433"><td class="memItemLeft" align="right" valign="top"><a id="a0261edf1d643dd42d8791c74d9b06433" name="a0261edf1d643dd42d8791c74d9b06433"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkQueueLimits</b> ()</td></tr>
<tr class="memdesc:a0261edf1d643dd42d8791c74d9b06433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the queue limit, discarding events as necessary. <br /></td></tr>
<tr class="separator:a0261edf1d643dd42d8791c74d9b06433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c23106d679ecf42a5c4a055b8e8b3" id="r_aea0c23106d679ecf42a5c4a055b8e8b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea0c23106d679ecf42a5c4a055b8e8b3">lock</a> ()</td></tr>
<tr class="memdesc:aea0c23106d679ecf42a5c4a055b8e8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the queue protection mutex.  <br /></td></tr>
<tr class="separator:aea0c23106d679ecf42a5c4a055b8e8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ead0b1e95e512a3cdaf9a7f364e0a34" id="r_a3ead0b1e95e512a3cdaf9a7f364e0a34"><td class="memItemLeft" align="right" valign="top"><a id="a3ead0b1e95e512a3cdaf9a7f364e0a34" name="a3ead0b1e95e512a3cdaf9a7f364e0a34"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryLock</b> ()</td></tr>
<tr class="memdesc:a3ead0b1e95e512a3cdaf9a7f364e0a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt the queue protection mutex. <br /></td></tr>
<tr class="separator:a3ead0b1e95e512a3cdaf9a7f364e0a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c241c63e7d05fe1d4d189521b53c89" id="r_a92c241c63e7d05fe1d4d189521b53c89"><td class="memItemLeft" align="right" valign="top"><a id="a92c241c63e7d05fe1d4d189521b53c89" name="a92c241c63e7d05fe1d4d189521b53c89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock</b> ()</td></tr>
<tr class="memdesc:a92c241c63e7d05fe1d4d189521b53c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the queue protection mutex. <br /></td></tr>
<tr class="separator:a92c241c63e7d05fe1d4d189521b53c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7be22f9aadeb823f0e245d341ac89622" id="r_a7be22f9aadeb823f0e245d341ac89622"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be22f9aadeb823f0e245d341ac89622">instance</a> ()</td></tr>
<tr class="memdesc:a7be22f9aadeb823f0e245d341ac89622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the singleton instance of this class.  <br /></td></tr>
<tr class="separator:a7be22f9aadeb823f0e245d341ac89622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a24252b9b568520bb510c8b4608e65d4a" id="r_a24252b9b568520bb510c8b4608e65d4a"><td class="memItemLeft" align="right" valign="top"><a id="a24252b9b568520bb510c8b4608e65d4a" name="a24252b9b568520bb510c8b4608e65d4a"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>kQueueFileTrailerMagic</b> = 0x55fcab58</td></tr>
<tr class="memdesc:a24252b9b568520bb510c8b4608e65d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic bytes stored in the <a class="el" href="struct_publish_queue_ext_1_1_queue_file_trailer.html" title="This structure is at the end of the publish queue file.">QueueFileTrailer</a> structure. <br /></td></tr>
<tr class="separator:a24252b9b568520bb510c8b4608e65d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa4c50489c84bbcabc1ce32f87ceeaf57" id="r_aa4c50489c84bbcabc1ce32f87ceeaf57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4c50489c84bbcabc1ce32f87ceeaf57">PublishQueueExt</a> ()</td></tr>
<tr class="memdesc:aa4c50489c84bbcabc1ce32f87ceeaf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aa4c50489c84bbcabc1ce32f87ceeaf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f224ea1f95cdeeead289dbf4cc3f05e" id="r_a2f224ea1f95cdeeead289dbf4cc3f05e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f224ea1f95cdeeead289dbf4cc3f05e">~PublishQueueExt</a> ()</td></tr>
<tr class="memdesc:a2f224ea1f95cdeeead289dbf4cc3f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a2f224ea1f95cdeeead289dbf4cc3f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e56ca5eef5da9065f1789e1817e2f9f" id="r_a6e56ca5eef5da9065f1789e1817e2f9f"><td class="memItemLeft" align="right" valign="top"><a id="a6e56ca5eef5da9065f1789e1817e2f9f" name="a6e56ca5eef5da9065f1789e1817e2f9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PublishQueueExt</b> (const <a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6e56ca5eef5da9065f1789e1817e2f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a6e56ca5eef5da9065f1789e1817e2f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccfa8736669135f5628f55e4179ee36" id="r_a0ccfa8736669135f5628f55e4179ee36"><td class="memItemLeft" align="right" valign="top"><a id="a0ccfa8736669135f5628f55e4179ee36" name="a0ccfa8736669135f5628f55e4179ee36"></a>
<a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;)=delete</td></tr>
<tr class="memdesc:a0ccfa8736669135f5628f55e4179ee36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a0ccfa8736669135f5628f55e4179ee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accedd211169048f89b7ee11a80e7448f" id="r_accedd211169048f89b7ee11a80e7448f"><td class="memItemLeft" align="right" valign="top"><a id="accedd211169048f89b7ee11a80e7448f" name="accedd211169048f89b7ee11a80e7448f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteCurEvent</b> ()</td></tr>
<tr class="memdesc:accedd211169048f89b7ee11a80e7448f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the current event in curFileNum. <br /></td></tr>
<tr class="separator:accedd211169048f89b7ee11a80e7448f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd7817a2cae30d38505c6531c622fec" id="r_a9cd7817a2cae30d38505c6531c622fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cd7817a2cae30d38505c6531c622fec">stateConnectWait</a> ()</td></tr>
<tr class="memdesc:a9cd7817a2cae30d38505c6531c622fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting to connect to the Particle cloud.  <br /></td></tr>
<tr class="separator:a9cd7817a2cae30d38505c6531c622fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a54dcc0320130647dbf5f6d3f59106" id="r_ab1a54dcc0320130647dbf5f6d3f59106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1a54dcc0320130647dbf5f6d3f59106">stateWaitEvent</a> ()</td></tr>
<tr class="memdesc:ab1a54dcc0320130647dbf5f6d3f59106"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting for an event.  <br /></td></tr>
<tr class="separator:ab1a54dcc0320130647dbf5f6d3f59106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98354b124f4b5ee21ceb3aa8a8f9d329" id="r_a98354b124f4b5ee21ceb3aa8a8f9d329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98354b124f4b5ee21ceb3aa8a8f9d329">statePublishWait</a> ()</td></tr>
<tr class="memdesc:a98354b124f4b5ee21ceb3aa8a8f9d329"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting for publish to complete.  <br /></td></tr>
<tr class="separator:a98354b124f4b5ee21ceb3aa8a8f9d329"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aeeb20b2e01d4760cebaf62efc5391f0f" id="r_aeeb20b2e01d4760cebaf62efc5391f0f"><td class="memItemLeft" align="right" valign="top"><a id="aeeb20b2e01d4760cebaf62efc5391f0f" name="aeeb20b2e01d4760cebaf62efc5391f0f"></a>
SequentialFile&#160;</td><td class="memItemRight" valign="bottom"><b>fileQueue</b></td></tr>
<tr class="memdesc:aeeb20b2e01d4760cebaf62efc5391f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SequentialFileRK library object for maintaining the queue of files on the POSIX file system. <br /></td></tr>
<tr class="separator:aeeb20b2e01d4760cebaf62efc5391f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4a0dd857a75d825f77522ff5b61571" id="r_a0d4a0dd857a75d825f77522ff5b61571"><td class="memItemLeft" align="right" valign="top"><a id="a0d4a0dd857a75d825f77522ff5b61571" name="a0d4a0dd857a75d825f77522ff5b61571"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><b>tempFileName</b> = &quot;temp.dat&quot;</td></tr>
<tr class="memdesc:a0d4a0dd857a75d825f77522ff5b61571"><td class="mdescLeft">&#160;</td><td class="mdescRight">File used for temporary data. <br /></td></tr>
<tr class="separator:a0d4a0dd857a75d825f77522ff5b61571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f88cb51a5f41b9421840fa5a31bf2da" id="r_a8f88cb51a5f41b9421840fa5a31bf2da"><td class="memItemLeft" align="right" valign="top"><a id="a8f88cb51a5f41b9421840fa5a31bf2da" name="a8f88cb51a5f41b9421840fa5a31bf2da"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><b>tempFilePath</b></td></tr>
<tr class="memdesc:a8f88cb51a5f41b9421840fa5a31bf2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill path name to tempFileName. <br /></td></tr>
<tr class="separator:a8f88cb51a5f41b9421840fa5a31bf2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93fca15049de23826db33c3abde4fbc" id="r_ac93fca15049de23826db33c3abde4fbc"><td class="memItemLeft" align="right" valign="top"><a id="ac93fca15049de23826db33c3abde4fbc" name="ac93fca15049de23826db33c3abde4fbc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>fileQueueSize</b> = 100</td></tr>
<tr class="memdesc:ac93fca15049de23826db33c3abde4fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the queue on the flash file system <br /></td></tr>
<tr class="separator:ac93fca15049de23826db33c3abde4fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbdfccea7f5eb5794644ba07fc4180b" id="r_a1bbdfccea7f5eb5794644ba07fc4180b"><td class="memItemLeft" align="right" valign="top"><a id="a1bbdfccea7f5eb5794644ba07fc4180b" name="a1bbdfccea7f5eb5794644ba07fc4180b"></a>
os_mutex_recursive_t&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="memdesc:a1bbdfccea7f5eb5794644ba07fc4180b"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for protecting the queue <br /></td></tr>
<tr class="separator:a1bbdfccea7f5eb5794644ba07fc4180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ca9190691ae035531b4dea8a8ec1ae" id="r_a84ca9190691ae035531b4dea8a8ec1ae"><td class="memItemLeft" align="right" valign="top"><a id="a84ca9190691ae035531b4dea8a8ec1ae" name="a84ca9190691ae035531b4dea8a8ec1ae"></a>
CloudEvent&#160;</td><td class="memItemRight" valign="bottom"><b>curEvent</b></td></tr>
<tr class="memdesc:a84ca9190691ae035531b4dea8a8ec1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current event being published. <br /></td></tr>
<tr class="separator:a84ca9190691ae035531b4dea8a8ec1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d7fa440712cce204b18d6412cf823f" id="r_a42d7fa440712cce204b18d6412cf823f"><td class="memItemLeft" align="right" valign="top"><a id="a42d7fa440712cce204b18d6412cf823f" name="a42d7fa440712cce204b18d6412cf823f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>curFileNum</b> = 0</td></tr>
<tr class="memdesc:a42d7fa440712cce204b18d6412cf823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current file number being published. <br /></td></tr>
<tr class="separator:a42d7fa440712cce204b18d6412cf823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234667db5e6aa8df0084911ed3daad7a" id="r_a234667db5e6aa8df0084911ed3daad7a"><td class="memItemLeft" align="right" valign="top"><a id="a234667db5e6aa8df0084911ed3daad7a" name="a234667db5e6aa8df0084911ed3daad7a"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>stateTime</b> = 0</td></tr>
<tr class="memdesc:a234667db5e6aa8df0084911ed3daad7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">millis() value when entering the state, used for stateWait <br /></td></tr>
<tr class="separator:a234667db5e6aa8df0084911ed3daad7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b07410a3083bddc65def3b5396830e0" id="r_a8b07410a3083bddc65def3b5396830e0"><td class="memItemLeft" align="right" valign="top"><a id="a8b07410a3083bddc65def3b5396830e0" name="a8b07410a3083bddc65def3b5396830e0"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>durationMs</b> = 0</td></tr>
<tr class="memdesc:a8b07410a3083bddc65def3b5396830e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait before publishing in milliseconds, used in stateWait <br /></td></tr>
<tr class="separator:a8b07410a3083bddc65def3b5396830e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d66e14a90ca1539eeb092efd30d116" id="r_a65d66e14a90ca1539eeb092efd30d116"><td class="memItemLeft" align="right" valign="top"><a id="a65d66e14a90ca1539eeb092efd30d116" name="a65d66e14a90ca1539eeb092efd30d116"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pausePublishing</b> = false</td></tr>
<tr class="memdesc:a65d66e14a90ca1539eeb092efd30d116"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to pause publishing (used from automated test) <br /></td></tr>
<tr class="separator:a65d66e14a90ca1539eeb092efd30d116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d584da8e902a147999d76ce9e678dd0" id="r_a2d584da8e902a147999d76ce9e678dd0"><td class="memItemLeft" align="right" valign="top"><a id="a2d584da8e902a147999d76ce9e678dd0" name="a2d584da8e902a147999d76ce9e678dd0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSleep</b> = false</td></tr>
<tr class="memdesc:a2d584da8e902a147999d76ce9e678dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if this is a good time to go to sleep <br /></td></tr>
<tr class="separator:a2d584da8e902a147999d76ce9e678dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0c78692b3b1be99d339519a4334de2" id="r_a8d0c78692b3b1be99d339519a4334de2"><td class="memItemLeft" align="right" valign="top"><a id="a8d0c78692b3b1be99d339519a4334de2" name="a8d0c78692b3b1be99d339519a4334de2"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitAfterConnect</b> = 500</td></tr>
<tr class="memdesc:a8d0c78692b3b1be99d339519a4334de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">time to wait after Particle.connected() before publishing <br /></td></tr>
<tr class="separator:a8d0c78692b3b1be99d339519a4334de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae2d0ab68314d98b22f0e3f6a85d2fd" id="r_abae2d0ab68314d98b22f0e3f6a85d2fd"><td class="memItemLeft" align="right" valign="top"><a id="abae2d0ab68314d98b22f0e3f6a85d2fd" name="abae2d0ab68314d98b22f0e3f6a85d2fd"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitBetweenPublish</b> = 10</td></tr>
<tr class="memdesc:abae2d0ab68314d98b22f0e3f6a85d2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait in milliseconds between publishes <br /></td></tr>
<tr class="separator:abae2d0ab68314d98b22f0e3f6a85d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f45886f0bbd0212df5113d2188b395" id="r_a00f45886f0bbd0212df5113d2188b395"><td class="memItemLeft" align="right" valign="top"><a id="a00f45886f0bbd0212df5113d2188b395" name="a00f45886f0bbd0212df5113d2188b395"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitAfterFailure</b> = 30000</td></tr>
<tr class="memdesc:a00f45886f0bbd0212df5113d2188b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait after failing to publish before trying again <br /></td></tr>
<tr class="separator:a00f45886f0bbd0212df5113d2188b395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cc98efedc05f404ab034d2fb226cf0" id="r_a60cc98efedc05f404ab034d2fb226cf0"><td class="memItemLeft" align="right" valign="top"><a id="a60cc98efedc05f404ab034d2fb226cf0" name="a60cc98efedc05f404ab034d2fb226cf0"></a>
std::function&lt; void(const CloudEvent &amp;event)&#160;</td><td class="memItemRight" valign="bottom"><b>publishCompleteUserCallback</b> ) = 0</td></tr>
<tr class="memdesc:a60cc98efedc05f404ab034d2fb226cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback for publish complete. <br /></td></tr>
<tr class="separator:a60cc98efedc05f404ab034d2fb226cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2099e8ec9290cbe6391fb82056b16d8b" id="r_a2099e8ec9290cbe6391fb82056b16d8b"><td class="memItemLeft" align="right" valign="top"><a id="a2099e8ec9290cbe6391fb82056b16d8b" name="a2099e8ec9290cbe6391fb82056b16d8b"></a>
std::function&lt; void(<a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp;)&#160;</td><td class="memItemRight" valign="bottom"><b>stateHandler</b> ) = 0</td></tr>
<tr class="memdesc:a2099e8ec9290cbe6391fb82056b16d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">state handler (stateConnectWait, stateWait, etc). <br /></td></tr>
<tr class="separator:a2099e8ec9290cbe6391fb82056b16d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a28a25587f309ca6821a085ead404b25b" id="r_a28a25587f309ca6821a085ead404b25b"><td class="memItemLeft" align="right" valign="top"><a id="a28a25587f309ca6821a085ead404b25b" name="a28a25587f309ca6821a085ead404b25b"></a>
static <a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_instance</b></td></tr>
<tr class="memdesc:a28a25587f309ca6821a085ead404b25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">singleton instance of this class <br /></td></tr>
<tr class="separator:a28a25587f309ca6821a085ead404b25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for asynchronous publishing of events. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa4c50489c84bbcabc1ce32f87ceeaf57" name="aa4c50489c84bbcabc1ce32f87ceeaf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c50489c84bbcabc1ce32f87ceeaf57">&#9670;&#160;</a></span>PublishQueueExt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueueExt::PublishQueueExt </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This class is a singleton; you never create one of these directly. Use <a class="el" href="#a7be22f9aadeb823f0e245d341ac89622" title="Gets the singleton instance of this class.">PublishQueueExt::instance()</a> to get the singleton instance. </p>

</div>
</div>
<a id="a2f224ea1f95cdeeead289dbf4cc3f05e" name="a2f224ea1f95cdeeead289dbf4cc3f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f224ea1f95cdeeead289dbf4cc3f05e">&#9670;&#160;</a></span>~PublishQueueExt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueueExt::~PublishQueueExt </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This class is never deleted; once the singleton is created it cannot be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41d836715f52f69367b2fbc32ac7f626" name="a41d836715f52f69367b2fbc32ac7f626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d836715f52f69367b2fbc32ac7f626">&#9670;&#160;</a></span>getCanSleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueExt::getCanSleep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if it's a good time to go to sleep. </p>
<p>If a publish is not in progress and the queue is empty, returns true.</p>
<p>If pausePublishing is true, then return true if either the current publish has completed, or not cloud connected. </p>

</div>
</div>
<a id="af469e16e7fdd0d552b944d2418aedead" name="af469e16e7fdd0d552b944d2418aedead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af469e16e7fdd0d552b944d2418aedead">&#9670;&#160;</a></span>getDirPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * PublishQueueExt::getDirPath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the directory path set using <a class="el" href="#a5fd49955e24427561875e23305a6aa9c" title="Sets the directory to use as the queue directory. This is required!">withDirPath()</a> </p>
<p>The returned path will not end with a slash. </p>

</div>
</div>
<a id="a45e82c9642ecfa120db037c0ecb559d8" name="a45e82c9642ecfa120db037c0ecb559d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e82c9642ecfa120db037c0ecb559d8">&#9670;&#160;</a></span>getNumEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PublishQueueExt::getNumEvents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of events queued. </p>
<p>This operation is fast; the file queue length is stored in RAM, so this command does not need to access the file system.</p>
<p>If an event is currently being sent, the result includes this event. </p>

</div>
</div>
<a id="a7be22f9aadeb823f0e245d341ac89622" name="a7be22f9aadeb823f0e245d341ac89622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be22f9aadeb823f0e245d341ac89622">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp; PublishQueueExt::instance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the singleton instance of this class. </p>
<p>You cannot construct a <a class="el" href="class_publish_queue_ext.html" title="Class for asynchronous publishing of events.">PublishQueueExt</a> object as a global variable, stack variable, or with new. You can only request the singleton instance. </p>

</div>
</div>
<a id="aea0c23106d679ecf42a5c4a055b8e8b3" name="aea0c23106d679ecf42a5c4a055b8e8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0c23106d679ecf42a5c4a055b8e8b3">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueExt::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the queue protection mutex. </p>
<p>This is done internally; you probably won't need to call this yourself. It needs to be public for the WITH_LOCK() macro to work properly. </p>

</div>
</div>
<a id="aff3b51718306124c20d8ad186f5538eb" name="aff3b51718306124c20d8ad186f5538eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3b51718306124c20d8ad186f5538eb">&#9670;&#160;</a></span>publish() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueExt::publish </td>
          <td>(</td>
          <td class="paramtype">CloudEvent</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a3612467432edb9b35532f316cc604dde" name="a3612467432edb9b35532f316cc604dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3612467432edb9b35532f316cc604dde">&#9670;&#160;</a></span>publish() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueExt::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a40539be5431fb4797dba65eddfbc73e2" name="a40539be5431fb4797dba65eddfbc73e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40539be5431fb4797dba65eddfbc73e2">&#9670;&#160;</a></span>publish() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueExt::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The UTF-8 text event data as a c-string. It is copied by this method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a9030cdc4d59259aa514056534f546d43" name="a9030cdc4d59259aa514056534f546d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9030cdc4d59259aa514056534f546d43">&#9670;&#160;</a></span>publish() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueExt::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variant &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for publishing an event from a Variant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>Reference to a Variant object holding the data. It is copied by this method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.</p>
<p>In some cases the content type can be inferred, such as when the <code>Variant</code> is a <code>VariantMap</code> but normally you will want to use the overload with a <code>ContentType</code>. </p>

</div>
</div>
<a id="ade52d7bc6df525c3fbf576740d6b92e2" name="ade52d7bc6df525c3fbf576740d6b92e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade52d7bc6df525c3fbf576740d6b92e2">&#9670;&#160;</a></span>publish() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueExt::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variant &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for publishing an event with a Variant and ContentType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>Reference to a Variant object holding the data. It is copied by this method.</td></tr>
    <tr><td class="paramname">type</td><td>The ContentType of the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.</p>
<p>Content Type Constant MIME Type Value ContentType::TEXT text/plain; charset=utf-8 0 ContentType::JPEG image/jpeg 22 ContentType::PNG image/png 23 ContentType::BINARY application/octet-stream 42 ContentType::STRUCTURED 65001 </p>

</div>
</div>
<a id="abc5477889eea9b5555a70e9ad19dc000" name="abc5477889eea9b5555a70e9ad19dc000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5477889eea9b5555a70e9ad19dc000">&#9670;&#160;</a></span>setPausePublishing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueExt::setPausePublishing </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or resume publishing events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to set, true = pause, false = normal operation</td></tr>
  </table>
  </dd>
</dl>
<p>If called while a publish is in progress, that publish will still proceed, but the next event (if any) will not be attempted.</p>
<p>This is used by the automated test tool; you probably won't need to manually manage this under normal circumstances. </p>

</div>
</div>
<a id="a9cd7817a2cae30d38505c6531c622fec" name="a9cd7817a2cae30d38505c6531c622fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd7817a2cae30d38505c6531c622fec">&#9670;&#160;</a></span>stateConnectWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueExt::stateConnectWait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting to connect to the Particle cloud. </p>
<p>Next state: stateWait </p>

</div>
</div>
<a id="a98354b124f4b5ee21ceb3aa8a8f9d329" name="a98354b124f4b5ee21ceb3aa8a8f9d329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98354b124f4b5ee21ceb3aa8a8f9d329">&#9670;&#160;</a></span>statePublishWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueExt::statePublishWait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting for publish to complete. </p>
<p>Next state: stateWait </p>

</div>
</div>
<a id="ab1a54dcc0320130647dbf5f6d3f59106" name="ab1a54dcc0320130647dbf5f6d3f59106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a54dcc0320130647dbf5f6d3f59106">&#9670;&#160;</a></span>stateWaitEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueExt::stateWaitEvent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting for an event. </p>
<p>stateTime and durationMs determine whether to stay in this state waiting, or whether to publish and go into statePublishWait.</p>
<p>Next state: stateWaitRateLimit or stateConnectWait </p>

</div>
</div>
<a id="a5fd49955e24427561875e23305a6aa9c" name="a5fd49955e24427561875e23305a6aa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd49955e24427561875e23305a6aa9c">&#9670;&#160;</a></span>withDirPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp; PublishQueueExt::withDirPath </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dirPath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the directory to use as the queue directory. This is required! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirPath</td><td>the pathname, Unix-style with / as the directory separator.</td></tr>
  </table>
  </dd>
</dl>
<p>Typically you create your queue either at the top level ("/myqueue") or in /usr ("/usr/myqueue"). The directory will be created if necessary, however only one level of directory will be created. The parent must already exist.</p>
<p>The dirPath can end with a slash or not, but if you include it, it will be removed.</p>
<p>You must call this as you cannot use the root directory as a queue! </p>

</div>
</div>
<a id="a45c6e19557266a4a33ab51ad5d2a80d0" name="a45c6e19557266a4a33ab51ad5d2a80d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c6e19557266a4a33ab51ad5d2a80d0">&#9670;&#160;</a></span>withFileQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp; PublishQueueExt::withFileQueueSize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the file-based queue size (default is 100) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The maximum number of files to store (one event per file)</td></tr>
  </table>
  </dd>
</dl>
<p>If you exceed this number of events, the oldest event is discarded. </p>

</div>
</div>
<a id="a076c74a202967ed8d7560508373e7873" name="a076c74a202967ed8d7560508373e7873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076c74a202967ed8d7560508373e7873">&#9670;&#160;</a></span>withPublishCompleteUserCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_ext.html">PublishQueueExt</a> &amp; PublishQueueExt::withPublishCompleteUserCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const CloudEvent &amp;event)&gt;</td>          <td class="paramname"><span class="paramname"><em>cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback function to call with publish is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback function or C++ lambda. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_publish_queue_ext.html" title="Class for asynchronous publishing of events.">PublishQueueExt</a>&amp;</dd></dl>
<p>The callback has this prototype and can be a function or a C++11 lambda, which allows the callback to be a class method.</p>
<p>void callback(const CloudEvent &amp;event)</p>
<p>The parameters are:</p><ul>
<li>event: The CloudEvent object that was just sent</li>
</ul>
<p>You can determine success/failure, examine the event. or the event data, by using methods of the CloudEvent class</p>
<p>Note that this callback will be called from the background thread used for publishing. You should not perform any lengthy operations and you should avoid using large amounts of stack space during this callback. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_publish_queue_ext_r_k_8h_source.html">PublishQueueExtRK.h</a></li>
<li>src/<b>PublishQueueExtRK.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
